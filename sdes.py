#Define keys initially
IP = [2, 6, 3, 1, 4, 8, 5, 7]
EP = [4, 1, 2, 3, 2, 3, 4, 1]
IP_inverse = [4, 1, 3, 5, 7, 2, 8, 6]
P10 = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]
P8 = [6, 3, 7, 4, 8, 5, 10, 9]
P4 = [2, 4, 3, 1]

sbox0 = [[1, 0, 3, 2],
		 [3, 2, 1, 0],
		 [0, 2, 1, 3],
		 [3, 1, 3, 2]]

sbox1 = [[0, 1, 2, 3],
		 [2, 0, 1, 3],
		 [3, 0, 1, 0],
		 [2, 1, 0, 3]]

default_key = '1010000010'

#Function which returns a string of bits randomized based on the key being used
def permutate(original, key):
	return ''.join(original[i-1] for i in key)
	#bitList = []
	#for char in bitString:
	#	if char == '1':
	#		bitList.append(1)
	#	else:
	#		bitList.append(0)
	#return bitList

#Returns the left half of bits in any key
def keyLeftHalf(bits):
	return bits[:(len(bits)/2)]

#Returns the right half of bits in any key
def keyRightHalf(bits):
	return bits[(len(bits)/2):]

#Split the bits passed in into 2 different halves, and then perform a leftwise shift on each half
#and returns the combined result
def shift(bits):
	leftHalfShift = keyLeftHalf(bits)[1:] + keyLeftHalf(bits)[0]
	rightHalfShift = keyRightHalf(bits)[1:] + keyRightHalf(bits)[0]
	return leftHalfShift+rightHalfShift

#This function generates the key from the first round of shifts
def generateKey1():
	return permutate(shift(permutate(default_key, P10)), P8)

#This function generates the key from the second round of shifts
def generateKey2():
	return permutate(shift(shift(shift(permutate(default_key, P10)))), P8)

#XOR function, this returns the string of bits created by applying the XOR operation between 2 bits
def xor(bits, key):
	newBitString = ''
	for bit, key_bit in zip(map(int, bits), map(int, key)):
		if (bit != key_bit):
			newBitString = newBitString + '1'
		else:
			newBitString = newBitString + '0'
	return newBitString

#This performs the non-linear sbox operations, which will transform the bits used as input
#based on the sbox tables defined above
def sboxLookup(bits, sbox):
	row = int(bits[0] + bits[3], 2)
	col = int(bits[1] + bits[2], 2)
	return '{0:02b}'.format(sbox[row][col])

#This is the function which will actually perform the DES algorithm by using the
#helper functions above
def fk(bits, key):
	#Split the bits into left and right halves
	left = keyLeftHalf(bits)
	right = keyRightHalf(bits)
	#Permutate the right half
	bits = permutate(right, EP)
	bits = xor(bits, key)
	#Transform the bits using the sbox table
	bits = sboxLookup(keyLeftHalf(bits), sbox0) + sboxLookup(keyRightHalf(bits), sbox1)
	#Permutate the resulting bits using the 4 bit key
	bits = permutate(bits, P4)
	#Perform xor operation on the 
	return xor(bits, left)

#Encryption call takes 8 bit inputs and calls the DES functions in order
def encrypt(plainText):
	#bits = stringToBits(plainText)
	#Cipher the bits according to the IP key
	bits = permutate(plainText, IP)
	#Store the first key generated by the DES algorithm
	temp = fk(bits, generateKey1())
	#Generate the second key for the DES algorithm
	bits = keyRightHalf(bits) + temp
	bits = fk(bits, generateKey2())
	#Return the resulting encrypted string of bytes
	return permutate(bits + temp, IP_inverse)

#Decryption call has identical operations as encrypt, with the exception of
#calling the Key2 function first
def decrypt(cipherText):
	bits = permutate(cipherText, IP)
	temp = fk(bits, generateKey2())
	bits = keyRightHalf(bits) + temp
	bits = fk(bits, generateKey1())
	return permutate(bits + temp, IP_inverse)